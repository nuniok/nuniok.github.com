<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/resource/img/fav2024.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/resource/img/fav2024.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/resource/img/fav2024.png">
  <link rel="mask-icon" href="/resource/img/fav2024.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"noge.top","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2929408904388376" crossorigin="anonymous"></script><meta property="og:type" content="website">
<meta property="og:title" content="码力欧">
<meta property="og:url" content="https://noge.top/index.html">
<meta property="og:site_name" content="码力欧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="nuniok">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://noge.top/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>码力欧</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?9cdc9a11cbd242c6336b07c464d8820c"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">码力欧</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">的业余生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-career"><a href="/career/" rel="section"><i class="sitemap fa-fw"></i>├ 技术</a></li>
        <li class="menu-item menu-item-life"><a href="/life/" rel="section"><i class="sitemap fa-fw"></i>├ 生活</a></li>
        <li class="menu-item menu-item-future"><a href="/future/" rel="section"><i class="sitemap fa-fw"></i>└ 未来</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">nuniok</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">93</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/nuniok" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nuniok" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:nuniok@163.com" title="E-Mail → mailto:nuniok@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/06/25/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/25/1.html" class="post-title-link" itemprop="url">软件系统表达方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-25T00:00:00+00:00">2020-06-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这边文章是想总结一下软件系统的设计表达方式，通过什么样的方式可以让你更有效的表达你的系统设计，如何让别人更清晰的去理解你的系统，以及在多人协作开发的时候如何让别人理解不同模块间的职责，明确每个人要做的事情。旨在提高协作效率，让你的系统不再沉默。在软件开发的各层次设计中最主要的是也是开发人员最不喜欢的是写文档，而文档中的图表也是你表达的一个关键点，接下来是要总结下不同表达层次的图表使用示例。总结下平时用到的一些图表以及使用场景。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/resource/img/2020-06-25-13-06-44.png"></p>
<h2 id="泳道图"><a href="#泳道图" class="headerlink" title="泳道图"></a>泳道图</h2><p><img src="/resource/img/2020-06-25-14-03-32.png"></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/resource/img/2020-06-25-14-14-27.png"></p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/resource/img/2020-06-25-14-06-41.png"></p>
<h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><p><img src="/resource/img/2020-06-25-14-08-41.png"></p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/resource/img/2020-06-25-14-00-13.png"></p>
<h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><p><img src="/resource/img/2020-06-25-14-12-46.png"></p>
<h2 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h2><p><img src="/resource/img/2020-06-25-14-18-22.png"></p>
<p>模板来源： <a target="_blank" rel="noopener" href="https://v3.processon.com/popular">https://v3.processon.com/popular</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/05/11/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/11/1.html" class="post-title-link" itemprop="url">迈向优秀程序员的必经之路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-11T00:00:00+00:00">2020-05-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这个标题看起有点鸡汤文，不过我还是建议对以下总结出的几点做些深入思考，这些会在今后的工作中越来越多的感受到它的作用。</p>
<p><img src="/resource/img/2020-05-11-23-49-10.png"></p>
<h2 id="寻找你行业内的专家"><a href="#寻找你行业内的专家" class="headerlink" title="寻找你行业内的专家"></a>寻找你行业内的专家</h2><p>找到你所属行业内的专家，这些人往往做事高效并且很有才华。你要做的是跟随他们所关注的方向，学习他们做事的方法，思考如何应用到你的工作和生活上。找到他们，和他们去交流思考，提出自己的观点和想法。不要仅仅把眼光放到身边的人身上，这样会局限住你的视野。</p>
<h2 id="每天都写新代码"><a href="#每天都写新代码" class="headerlink" title="每天都写新代码"></a>每天都写新代码</h2><p>工作重复枯燥？也许有时候我们只是懒得思考，用最顺手的方式把工作做完，容易形成惯性思维。为什么会有很多的复制粘贴？简单的修改来适配当前需求，这里我们更需要的是想想能不能把这段逻辑抽象出来变得更通用，整个模块的设计是否不够合理，多想一想多做一点，下一次再来需求也许可以提升十倍的效率。</p>
<h2 id="底层的原理更重要"><a href="#底层的原理更重要" class="headerlink" title="底层的原理更重要"></a>底层的原理更重要</h2><p>客观的说，更快进步的方法之一是忽略掉那些并不能提高技能的东西，比如语言语法和配置工具，这些技能属于“知其然”，而你更需要的是“知其所以然”。有一次去医院科室挂号使用的是先到先叫的模式，而在急诊室挂号是按照轻重缓急分成四个等级的，危重病人优先抢救的模式。这不就和操作系统中的任务调度概念是一样的，优先级调度模式，这些底层的概念才是一通百通真正提高帮助你的东西。我在尝试去找行业经典论文看。</p>
<h2 id="学会调研"><a href="#学会调研" class="headerlink" title="学会调研"></a>学会调研</h2><p>作为程序员会比较容易脑子一热，有一个想法很容易趁热着急写代码，但往往缺乏思考写出来的代码不能尽如人意。这时候你更需要的是慢下来，好好思考一下，也许这些别人已经做过，有更好的方案，看看别人是如何做的。先调研再实施，这样会彻底改变你解决问题的思路。</p>
<h2 id="学好英语"><a href="#学好英语" class="headerlink" title="学好英语"></a>学好英语</h2><p>真的是这样，如果你英语不好，那么会比别人走更多的弯路，就像走在密林深处看不清路一样。不得不承认很多优秀框架的官方文档还是英文为主，如果再经过翻译里面的很多语义语境会丢失，在项目的社区中，你还能与作者们去交流你学习中遇到的问题。</p>
<h2 id="如何去做"><a href="#如何去做" class="headerlink" title="如何去做"></a>如何去做</h2><p>说了这么多，看着就好像道理我都懂，但是我不知道怎么做。我这里先总结几个点，也是自己在不断尝试学习的方法。</p>
<ol>
<li>看行业经典论文，比如 mapreduce、raft 这些都是一通百通的底层概念。</li>
<li>研究优秀框架的源代码，理解核心原理，尝试造轮子。</li>
<li>每天学英语，尝试在开源社区与作者们进行互动。</li>
<li>找到一两位行业专家，向他们学习和请教问题。</li>
<li>坚持以上几点。</li>
</ol>
<p>end.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/04/29/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/29/1.html" class="post-title-link" itemprop="url">动态代理实现 ORM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-29T00:00:00+00:00">2020-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ORM（Object&#x2F;Relational Mapper），即“对象-关系型数据映射组件”。对于O&#x2F;R，即 Object（对象）和Relational（关系型数据），表示必须同时使用面向对象和关系型数据进行开发。本文简述通过 Java 动态代理机制实现关系数据与 POJO 对象的映射。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理其实就是指设计模式中的代理模式。<br>代理模式为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><img src="/resource/img/2020-04-29-23-12-29.png"></p>
<p>静态代理模式在增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>为了解决静态代理的问题，引入动态代理的概念，在编译时或者运行时，可以在需要代理的地方动态生成代理，减轻代理类和类在系统中冗余的问题。</p>
<p><img src="/resource/img/2020-04-29-23-17-27.png"></p>
<p>Java 动态代理基于经典代理模式，引入了一个 InvocationHandler，InvocationHandler 负责统一管理所有的方法调用。</p>
<h4 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h4><p>InvocationHandler 接口定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface InvocationHandler &#123;</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">	        throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个动态代理类都必须要实现 InvocationHandler 这个接口，通过代理类的实例调用一个方法时，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>Proxy 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法，可以获得一个动态的代理对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)  throws IllegalArgumentException</span><br></pre></td></tr></table></figure>


<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参照 mybaits 的用法实现基本的映射能力。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>首先定义了三个注解，一个作用在类上 <code>DaoMapper</code> 作用在类上标记这是一个映射类，然后定义注解 <code>Selector</code> 作用在方法上标记查询作用，定义注解 <code>Param</code> 作用在参数上为预编译位的映射。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface DaoMapper &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Selector &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Target(ElementType.PARAMETER)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Param &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义一个实体类，与数据库的表字段映射上。增强 feature 可以自动做驼峰转换，这里没有实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class BaseLineModel &#123;</span><br><span class="line">    public static final String TABLE = &quot;baseline&quot;;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private String report_name;</span><br><span class="line">    private Integer report_period;</span><br><span class="line">    private LocalDateTime creation_date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义dao层接口，加上注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@DaoMapper</span><br><span class="line">public interface BaseLineDao &#123;</span><br><span class="line"></span><br><span class="line">    @Selector(&quot;select * from &quot;+ BaseLineModel.TABLE +&quot; where report_name = #&#123;reportName&#125;&quot;)</span><br><span class="line">    BaseLineModel select(@Param(&quot;reportName&quot;) String report_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="JDBC-OP"><a href="#JDBC-OP" class="headerlink" title="JDBC OP"></a>JDBC OP</h3><p>做到一个很简单的 JDBC 操作工具类，字段映射处理也写到了这里。实现了查询操作，将入参 sql template 以及参数按顺序传入，生成 <code>prepareStatement</code> 后执行，再将返回结果映射到 model 对象。这里的连接池管理、自动重连、配置管理等增强 features 非重点，不做实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 查询</span><br><span class="line">    * @param clazz model类</span><br><span class="line">    * @param sql</span><br><span class="line">    * @param params</span><br><span class="line">    * @param &lt;T&gt;</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">public &lt;T&gt; T query(Class&lt;T&gt; clazz, String sql, Object... params) throws SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">    Object model =  clazz.newInstance();</span><br><span class="line">    try (Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/cat&quot;, &quot;root&quot;, &quot;123456&quot;)) &#123;</span><br><span class="line">        PreparedStatement statement = conn.prepareStatement(sql);</span><br><span class="line">        int flag = 1;</span><br><span class="line">        for (Object obj : params) &#123;</span><br><span class="line">            setValue(statement, flag, obj);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        ResultSet resultSet = statement.executeQuery();</span><br><span class="line">        resultSet.afterLast();</span><br><span class="line">        resultSet.previous();</span><br><span class="line">        fullRes(resultSet, model);</span><br><span class="line">    &#125;</span><br><span class="line">    return (T) model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射函数，通过自动寻找 setter 方法填充结果，这里只实现了三种字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private static void fullRes(ResultSet resultSet, Object model) throws SQLException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">    Field[] declaredFields = model.getClass().getDeclaredFields();</span><br><span class="line">    for (Field field : declaredFields) &#123;</span><br><span class="line">        String fieldName = field.getName();</span><br><span class="line">        if (fieldName.toUpperCase().equals(fieldName)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        String setFuncName = &quot;set&quot; + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);</span><br><span class="line">        String fieldType = field.getGenericType().toString();</span><br><span class="line"></span><br><span class="line">        Object object = resultSet.getObject(fieldName);</span><br><span class="line">        if (fieldType.equals(&quot;class java.lang.String&quot;)) &#123;</span><br><span class="line">            Method m = model.getClass().getMethod(setFuncName, String.class);</span><br><span class="line">            m.invoke(model, object);</span><br><span class="line">        &#125; else if (fieldType.equals(&quot;class java.lang.Integer&quot;)) &#123;</span><br><span class="line">            Method m = model.getClass().getMethod(setFuncName, Integer.class);</span><br><span class="line">            m.invoke(model, object);</span><br><span class="line">        &#125; else if (fieldType.equals(&quot;class java.time.LocalDateTime&quot;)) &#123;</span><br><span class="line">            Method m = model.getClass().getMethod(setFuncName, LocalDateTime.class);</span><br><span class="line">            if (object instanceof Timestamp) &#123;</span><br><span class="line">                object = ((Timestamp) object).toLocalDateTime();</span><br><span class="line">            &#125;</span><br><span class="line">            m.invoke(model, object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态代理部分"><a href="#动态代理部分" class="headerlink" title="动态代理部分"></a>动态代理部分</h3><p>定义一个 <code>MapperMethod</code> 类，实例化的时候提取接口方法的注解信息解析成 JDBC 需要的参数以及记录接口方法的返回对象， <code>execute</code> 执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MapperMethod&lt;T&gt; &#123;</span><br><span class="line">    private String sql;</span><br><span class="line">    private Class&lt;?&gt; resType;</span><br><span class="line">    private int[] paramsIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MapperMethod(Method method) &#123;</span><br><span class="line">        this.resType = method.getReturnType();</span><br><span class="line">        String sourceSql = method.getAnnotation(Selector.class).value();</span><br><span class="line">        Parameter[] parameters = method.getParameters();</span><br><span class="line">        int flag = 0;</span><br><span class="line">        this.paramsIndex = new int[parameters.length];</span><br><span class="line">        for (Parameter parameter: parameters) &#123;</span><br><span class="line">            String paramName = parameter.getAnnotation(Param.class).value();</span><br><span class="line">            String paramFullName = String.format(&quot;#&#123;%s&#125;&quot;, paramName);</span><br><span class="line">            int indexOf = sourceSql.indexOf(paramFullName);</span><br><span class="line">            this.paramsIndex[flag] = indexOf;</span><br><span class="line">            flag++;</span><br><span class="line">            this.sql = sourceSql.replace(paramFullName, &quot;?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object execute(Object[] objects) &#123;</span><br><span class="line">        JdbcUtil jdbcUtil = new JdbcUtil();</span><br><span class="line">        try &#123;</span><br><span class="line">            return jdbcUtil.query(this.resType, this.sql, objects);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义动态代理类，在实例化的时候记录代理接口，以及代理方法类缓存，调用接口的时候会被动态代理到 <code>invoke</code> 函数执行，然后交由 <code>MapperMethod</code> 代理方法实例执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class MapperProxy&lt;T&gt; implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private final Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">    private final Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">    public MapperProxy(Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123;</span><br><span class="line">        this.mapperInterface = mapperInterface;</span><br><span class="line">        this.methodCache = methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;</span><br><span class="line">        MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">        return mapperMethod.execute(objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MapperMethod cachedMapperMethod(Method method) &#123;</span><br><span class="line">        MapperMethod mapperMethod = methodCache.get(method);</span><br><span class="line">        if (Objects.isNull(mapperMethod)) &#123;</span><br><span class="line">            mapperMethod = new MapperMethod(method);</span><br><span class="line">            methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        return mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后代理工厂类，接收被 <code>DaoMapper</code> 作用的接口，并通过 <code>newInstance</code> 方法创建代理类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxyFactory&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123;</span><br><span class="line">        if (Objects.isNull(mapperInterface.getAnnotation(DaoMapper.class))) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;缺少注解 DaoMapper&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public T newInstance() &#123;</span><br><span class="line">        final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(mapperInterface, methodCache);</span><br><span class="line">        return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]&#123;mapperInterface&#125;, mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行，创建一个代理工厂，然后创建 <code>BaseLineDao</code> 的代理对象， 调用 <code>select</code> 方法，实际上调用到代理对象的 <code>invoke</code> 方法，然后交由 <code> mapperMethod.execute</code> 方法执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MapperProxyFactory mapperProxyFactory = new MapperProxyFactory(BaseLineDao.class);</span><br><span class="line">    BaseLineDao baseLineDao = (BaseLineDao) mapperProxyFactory.newInstance();</span><br><span class="line">    BaseLineModel test1 = baseLineDao.select(&quot;TEST1&quot;);</span><br><span class="line">    System.out.println(test1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>TODO：</p>
<ol>
<li>Java动态代理与 cglib 动态代理的异同点。</li>
<li>动态代理的实现原理。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个个简单的实践，了解了 Java 动态代理的使用方法以及对象关系数据的映射处理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60805342">https://zhuanlan.zhihu.com/p/60805342</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20794107/answer/658139129">https://www.zhihu.com/question/20794107/answer/658139129</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/04/26/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/26/1.html" class="post-title-link" itemprop="url">Java 锁相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-26T00:00:00+00:00">2020-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>锁解决的问题是并发操作引起的脏读、数据不一致问题。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>在Java中允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保使用排它锁来单独获得这个变量，Java中提供了 volatile，使之在多处理器开发中保证变量的可见性，当一个线程改变了共享变量，另一个线程能够及时读到这个修改的值。恰当的使用它会比 synchronized 成本更低，因为不会引起上下文的切换和调度。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>通过锁机制实现同步，在Java中每一个对象都可以作为锁，有以下三种形式：</p>
<ul>
<li>对于普通同步方法，锁的是当前实例对象。</li>
<li>对于静态同步方法，所得是当前类 class 对象。</li>
<li>对于同步方法块，锁的是括号内指定的对象。</li>
</ul>
<p>为了减少获得锁和释放锁带来的性能消耗，Java SE 1.6 引入了偏向锁和轻量级锁。<strong>偏向锁</strong>的核心思想是：如果一个线程获得了锁，就进入偏向模式，当这个线程再次请求锁时，如果没有其它线程获取过该锁，无需再做任何同步操作，可以节省大量锁申请的操作，来提高性能。如果偏向锁获取失败，会通过<strong>轻量级锁</strong>的方式获取，如果获取成功则进入临界区，如果失败则表示有其它线程争夺到锁，当前线程锁请求会膨胀为<strong>重量级锁</strong>。</p>
<p><img src="/resource/img/2020-04-26-02-05-44.png"></p>
<p><strong>锁粗化</strong> 是指在遇到一连串连续的对同一个锁不断的进行请求和释放的操作时，会把所有的锁操作整合成对锁的一次请求，减少锁请求的同步次数。</p>
<p><strong>锁消除</strong> 是指在编译期，通过对上下文的扫描，去除不可能存在共享资源竞争的锁。</p>
<p><strong>自旋锁</strong> 是指在锁膨胀后，避免线程真正的在操作系统层面被挂起，通过对线程做几个空循环，以期望在这之后能获取到锁，顺利的进入临界区，如果还获取不到，则会真正被操作系统层面挂起。</p>
<p><img src="/resource/img/2020-04-26-02-14-59.png"></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>指的是比较并交换，它是一个原子操作，比较一个内存位置的值并且只有相等时修改这个内存位置的值并更新值，保证新的值总是基于最新的信息计算的。在 JVM 中 CAS 操作是利用处理器提供的 CMPXCHS 指令实现。是实现我们平时所说的自旋锁或乐观锁的核心操作。</p>
<p>优点是竞争小的时候使用系统开销小；对应缺点是循环时间长开销大、ABA问题、只能保证一个变量的原子操作。</p>
<h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>问题产生原因是两个线程处理的时间差导致，具体如下图：</p>
<p><img src="/resource/img/2020-04-26-01-21-06.png"></p>
<p>解决 ABA 问题可以增加一个版本号，在每次修改值的时候增加一个版本号。</p>
<p>产生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Integer&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t修改后的值:&quot;</span> + atomicReference.get());</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;Integer&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1拿到的初始版本号:&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//睡眠1秒，是为了让t2线程也拿到同样的初始版本号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">        atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">        System.out.println(<span class="string">&quot;t2拿到的初始版本号:&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//睡眠3秒，是为了让t1线程完成ABA操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最新版本号:&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        System.out.println(atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>,stamp,atomicStampedReference.getStamp() + <span class="number">1</span>) + <span class="string">&quot;\t当前 值:&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/04/14/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/14/1.html" class="post-title-link" itemprop="url">Raft 算法摘要</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-14T00:00:00+00:00">2020-04-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>Raft 算法是解决分布式系统一致性问题的，与 Paxos 实现的功能相同，相对来说更容易实现和理解。这些一致性协议可以保证在集群中大部分节点（半数以上节点）可用的情况下，集群依然可以工作并给出一个正确的结果。<br>Raft 将一致性问题分解为多个子模块解决：</p>
<ul>
<li>Leader 选举 Leader election</li>
<li>日志同步 log replication</li>
<li>安全性 safety</li>
<li>日志压缩 log compaction</li>
<li>成员变更 membership change</li>
</ul>
<p>Raft 将系统中的角色分为：</p>
<ul>
<li>Leader 接受客户端请求，并且向 Follower 同步请求日志，当日志同步到大多数节点上后告诉 Follower 提交日志。</li>
<li>Follower 接受并持久化 Leader 同步的日志，在 Leader 通知可以提交后提交日志。</li>
<li>Candidate 是选举过程中的临时角色。</li>
</ul>
<p><img src="/resource/img/2020-04-23-00-00-46.png"></p>
<p>Raft 要求系统在任何一个时刻最多只有一个 Leader，正常工作期间只有 Leader 和 Follower。<br>Raft 算法角色状态转换如下：</p>
<p><img src="/resource/img/2020-04-23-00-00-58.png"></p>
<p>Follower 只响应其它服务器的请求，如果 Flower 超时没有接受到 Leader 的消息，它会成为一个 Candidate 状态并开始一次 Leader 选举，收到大多数服务器投票的 Candidate 会成为新的 Leader，Leader 在宕机之前会一直保持 Leader 状态。</p>
<p><img src="/resource/img/2020-04-23-00-01-09.png"></p>
<p>Raft 算法将时间分为一个个的任期 term，每一个 term 的开始都是 Leader 选举，在成功选举 Leader 之后，Leader 会在整个 term 内管理整个集群，如果 Leader 选举失败，这个 term 就会因为没有 Leader 而结束。</p>
<h2 id="Leader-选举-Leader-election"><a href="#Leader-选举-Leader-election" class="headerlink" title="Leader 选举(Leader election)"></a>Leader 选举(Leader election)</h2><p>Raft 使用心跳触发 Leader 选举。当服务器启动时，初始化为 Follower。Leader 向所有 Follower 周期性发送 heartbeat。如果 Follower 选举超时，会等待一段随机时间后再发起一次 Leader选举。选举出 Leader 后，会定期向所有 Follower 发送 heartbeat 维持状态，如果 Follower 一段时间没有收到心跳则认为 Leader 已经挂了，再次发起Leader选举过程。</p>
<p><img src="/resource/img/2020-04-23-00-01-17.png"></p>
<h2 id="日志复制-log-replication"><a href="#日志复制-log-replication" class="headerlink" title="日志复制 (log replication)"></a>日志复制 (log replication)</h2><p>Leader 选举出来后，就开始接收客户端的请求，把日志条目加入到日志处理中，然后并行的向其它服务器发起请求复制日志条目。当这条日志被复制到大多数服务器中，Leader会把这条日志状态改变向客户端返回执行结果。</p>
<p><img src="/resource/img/2020-04-23-00-01-29.png"></p>
<p>如果某个Follower没有复制成功，则Leader会无限的重试直到Follower最终存储了所有的日志条目。日志由有序编号和日志条目组成，每条日志条目包含它被创建时的任期号 term，和用于状态机执行的命令。</p>
<p><img src="/resource/img/2020-04-23-00-01-37.png"></p>
<h2 id="安全性-safety"><a href="#安全性-safety" class="headerlink" title="安全性 (safety)"></a>安全性 (safety)</h2><p>Raft增加两条极限值来保证安全性：</p>
<ol>
<li>拥有最新已提交的log entry 的 Follower 才有资格成为 Leader</li>
<li>Leader只能推进commit index 来提交当前term的已经复制到大多数节点上的日志，旧的term日志会跟随当前term的日志来间接提交。</li>
</ol>
<p><img src="/resource/img/2020-04-23-00-01-48.png"></p>
<h2 id="日志压缩-log-compaction"><a href="#日志压缩-log-compaction" class="headerlink" title="日志压缩 (log compaction)"></a>日志压缩 (log compaction)</h2><p>通过定期记录 snapshot 来解决，每个副本独立的对自己系统状态进行snapshot，并且是已提交的日志进行。snapshot 包含日志元数据，最后一条已提交的 log entry 的 log index 和 term。Leader会发送snapshot给最后日志太多的Follower，或者新加入的机器。<br>copy-on-write <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012501054/article/details/90241124">https://blog.csdn.net/u012501054/article/details/90241124</a><br>做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p>
<h2 id="成员变更-membership-change"><a href="#成员变更-membership-change" class="headerlink" title="成员变更 (membership change)"></a>成员变更 (membership change)</h2><p>不同节点之间同步成员变更存在间隙，会导致一致性问题。Raft提出两阶段成员变更方法，集群从旧成员配置切换过度成员配置，叫做共同一致，是指旧成员配置和新成员配置组合，一旦共同一致被提交，系统再切换到新成员配置。</p>
<p><img src="/resource/img/2020-04-23-00-02-00.png"></p>
<p>Raft与Multi-Paxos的不同：</p>
<p><img src="/resource/img/2020-04-23-00-02-07.png"></p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><img src="/resource/img/%E5%A6%82%E6%9E%9C.png"></p>
<p><img src="/resource/img/2020-04-23-00-03-28.png"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32052223">https://zhuanlan.zhihu.com/p/32052223</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/04/06/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/06/1.html" class="post-title-link" itemprop="url">JVM 类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-06 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+00:00">2020-04-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java 类从源码到实例化对象需要经历几个过程</p>
<ol>
<li>编写Java源码（.java文件）</li>
<li>编译成Java字节码（.class文件）</li>
<li>类加载器读取字节码转换成java.lang.Class实例</li>
<li>JVM 通过 newInstance 等方法创建真正对象</li>
</ol>
<p>ClassLoader 是 Java 最基本的类加载器，用来实例化不同的类对象。Java类的来源可以有内部自带的核心类<code>$JAVA_HOME/jre/lib/</code>，核心扩展类<code>$JAVA_HOME/jre/lib/ext</code>，动态远程加载的<code>.class</code>文件，分别由不同的 ClassLoader 来协作加载。</p>
<p><img src="/resource/img/2020-04-05-23-58-25.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/04/05/3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/05/3.html" class="post-title-link" itemprop="url">VS Code 与 HEXO 结合写博客</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-05T00:00:00+00:00">2020-04-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 mac 机器上可以使用 mweb 来写博客，比较好用的地方就是可以直接把剪贴板的图片粘贴上来，缺点是 mac 键盘超难用并且不支持窗口内开启命令行。平时在家的时候都用 Ubuntu 台式机，博客使用 VS Code 编写，一直以来阻挡我的是图片的粘贴特别费劲，今天发现一个很好用的插件 pasteimage，可以直接将剪贴板图片粘贴到 markdown 使用，并且支持配置保存路径。</p>
<p><img src="/resource/img/2020-04-05-15-57-27.png"></p>
<p>然后按照教程配置好参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;pasteImage.path&quot;: &quot;$&#123;projectRoot&#125;/source/resource/img&quot;,</span><br><span class="line">    &quot;pasteImage.basePath&quot;: &quot;$&#123;projectRoot&#125;/source&quot;,</span><br><span class="line">    &quot;pasteImage.forceUnixStyleSeparator&quot;: true,</span><br><span class="line">    &quot;pasteImage.prefix&quot;: &quot;/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以直接将图片粘贴到 markdown 中，其中遇到个问题就是配置不生效，会导致文件直接保存到当前文件目录，具体配置方法可以参考下面连接。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.crifan.com/vscode_how_to_config_setting_plugin/">https://www.crifan.com/vscode_how_to_config_setting_plugin/</a>  这篇文章写的很详细了。<br><a target="_blank" rel="noopener" href="https://github.com/mushanshitiancai/vscode-paste-image">https://github.com/mushanshitiancai/vscode-paste-image</a> 这篇是配置教程，里面有些地方比较容易被误导。</p>
</blockquote>
<p>对于Linux系统需要有 xclip 支持，使用的时候会给提示的。</p>
<p><img src="/resource/img/2020-04-05-16-03-56.png"></p>
<p>另外记录一下 Ubuntu 的截屏和粘贴快捷键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + Print Screen  // 区域截屏到剪贴板</span><br><span class="line">Ctrl + Alt + s  // 在 VS Code 中粘贴</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/04/05/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/05/1.html" class="post-title-link" itemprop="url">开发工具箱 —— 基于 electron 和 FeHelper 的桌面 APP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-05T00:00:00+00:00">2020-04-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Chrome 上有个很好用的插件 FeHelper，应该是每个开发人员都在使用的，功能很全面。想着能不能搞个桌面版的，这样多屏环境下可以不用在众多 tab 页中找功能了。</p>
<p><img src="/resource/img/15860649053518.jpg"></p>
<p>桌面版实现，界面比较丑陋，不过用起来方便就行。这样可以在多屏环境下一个屏用来开啊，另一个屏可以观察辅助信息和使用小工具。<br><img src="/resource/img/15860653415972.jpg"></p>
<p>了解到 electron 是一个开源跨平台框架，可以使用 nodejs 做后端和 chromium 做前端开发。像 atom 和 vs code 使用这个框架开发的。觉得还是和方便的，主要是跨平台。而这个插件也是基于 nodejs 开发的，应该可以迁移过来。然后按照官方文档开发，通过 iframe load 不同页面。</p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/noogel/xyzToolbox">https://github.com/noogel/xyzToolbox</a></p>
<p>Mac 安装包下载地址:<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1SYjVX2Dhz6TTbaif1Bk8RA">https://pan.baidu.com/s/1SYjVX2Dhz6TTbaif1Bk8RA</a> 密码:64oo</p>
<p>拉取项目和子模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://xxx.git</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>

<p>打包命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">环境安装</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"># Linux打包成AppImage文件</span><br><span class="line"># 在Linux环境上执行</span><br><span class="line">node_modules/.bin/electron-builder -l AppImage</span><br><span class="line"></span><br><span class="line"># Windows打包成exe安装文件</span><br><span class="line"># 在Windows环境下执行</span><br><span class="line">node_modules/.bin/electron-builder -w nsis</span><br><span class="line">node_modules/.bin/electron-builder -w --ia32 nsis</span><br><span class="line"></span><br><span class="line"># 如果在非Windows上打包win程序，也可以借助docker 如下</span><br><span class="line"># docker run --rm -it -v $&#123;PWD&#125;:/project electronuserland/builder:wine sh -c &quot;node_modules/.bin/electron-builder -w nsis&quot;</span><br><span class="line"></span><br><span class="line"># Mac打包成dmg文件</span><br><span class="line"># 在Mac环境下执行</span><br><span class="line">node_modules/.bin/electron-builder -m dmg</span><br></pre></td></tr></table></figure>

<p>打包参考链接</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://qii404.me/2019/07/10/electron.html">https://qii404.me/2019/07/10/electron.html</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/04/05/2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/05/2.html" class="post-title-link" itemprop="url">JVM 运行时数据区</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-05T00:00:00+00:00">2020-04-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JVM-Runtime-Data-Area"><a href="#JVM-Runtime-Data-Area" class="headerlink" title="JVM Runtime Data Area"></a>JVM Runtime Data Area</h2><p>根据 JVM 规范，JVM 运行时内存共分为虚拟机栈、堆、元空间、程序计数器、本地方法栈五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。</p>
<p><img src="/resource/img/15860664146357.jpg"></p>
<p>线程私有：程序计数器，虚拟机栈，本地方法栈。<br>线程共享：堆、元空间、直接内存</p>
<ol>
<li><p>元空间(Metaspace），JDK 8 之前 HotSpot 虚拟机使用永久代来实现的方法区（方便内存管理）， JDK 8 废弃了永久代，将原来永久代的字符串常量池、静态变量、类型信息等全部移到了元空间中。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p>
</li>
<li><p>虚拟机栈(JVM Stacks），每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。</p>
</li>
<li><p>本地方法栈(Native Method Stack)，与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法站执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。</p>
</li>
<li><p>程序计数器(Program Counter Register)，程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。</p>
</li>
<li><p>堆内存(Heap)，堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在堆上进行分配。jdk1.8后，字符串常量池从永久代中剥离出来，存放在堆中。</p>
</li>
<li><p>直接内存(Direct Memory)，直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input&#x2F;Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I&#x2F;O 方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
</li>
</ol>
<h3 id="关于方区"><a href="#关于方区" class="headerlink" title="关于方区"></a>关于方区</h3><p><img src="/resource/img/2020-04-05-22-27-29.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noge.top/2020/04/05/4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nuniok">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码力欧">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/05/4.html" class="post-title-link" itemprop="url">JVM GC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-05T00:00:00+00:00">2020-04-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><ul>
<li>引用计数算法，记录对象被引用的次数。</li>
<li>可达性分析算法，通过一系列的“GC Roots” 根对象作为开始节点集，根据引用关系向下搜索，如果某个对象到 GC Roots 间没有任何引用链相连，表明对象不可达。</li>
</ul>
<p>引用的概念</p>
<ul>
<li>强引用，普遍的引用赋值。</li>
<li>软引用，在程序将要内存溢出的时候可以进行回收，回收后内存依然不够时则抛出异常。</li>
<li>弱引用，生存周期为下一次垃圾回收为止。</li>
<li>虚引用，被垃圾回收时触发一次系统通知。</li>
</ul>
<p>垃圾收集算法 - 分代收集理论</p>
<ul>
<li>内存区域<ul>
<li>新生代</li>
<li>老年代</li>
<li>永久代（元空间、方法区）</li>
</ul>
</li>
<li>回收类型<ul>
<li>新生代收集</li>
<li>老年代收集</li>
<li>整堆收集</li>
</ul>
</li>
<li>回收算法<ul>
<li>标记 - 清除算法：将垃圾对象标记清除。容易造成内存空间碎片化，大对象申请问题，可能触发下一次垃圾收集动作。</li>
<li>标记 - 复制算法：半区复制，浪费空间。新生代 eden 空间、两块 survivor 空间，比例是 8:1，每次只使用 Eden空间和一块survivor空间，进行垃圾回收时会将存活对象复制到另一块 survivor 空间，然后清理掉已经用过的 Eden 空间和 survivor 空间，这样整个新生代利用了 90% 的空间。当一次垃圾回收的存活对象超过一个surivor空间时会通过分配担保机制使用老年代空间。</li>
<li>标记 - 整理算法：清除后将所有存活对象向内存空间一端移动。</li>
</ul>
</li>
</ul>
<h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e197cc0e51d451c774dc56f">https://juejin.im/post/5e197cc0e51d451c774dc56f</a></p>
<p><img src="/resource/img/15860681718965.jpg"></p>
<p><img src="/resource/img/15860666420812.jpg"></p>
<p>Java8 GC 默认使用的是 Parallel Scavenge (新生代) 和 Parallel Old (老年代)。</p>
<h3 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h3><p>在启动命令中增加 <code>-XX:+PrintGCDetails</code> 输出详细GC日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM Args: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> * 堆内存溢出</span><br><span class="line"> */</span><br><span class="line">public class JvmDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        List&lt;Long&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(random.nextLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 8097K-&gt;1008K(9216K)] 11954K-&gt;10351K(19456K), 0.0091685 secs] [Times: user=0.02 sys=0.01, real=0.01 secs] </span><br><span class="line"></span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 1008K-&gt;495K(9216K)] [ParOldGen: 9343K-&gt;9793K(10240K)] 10351K-&gt;10288K(19456K), [Metaspace: 3224K-&gt;3224K(1056768K)], 0.1013312 secs] [Times: user=0.16 sys=0.00, real=0.10 secs] </span><br></pre></td></tr></table></figure>

<p>GC：表明进行了一次垃圾回收，前面没有Full修饰，表明这是一次Minor GC ,注意它不表示只GC新生代，并且现有的不管是新生代还是老年代都会STW。 Allocation Failure：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
<p><img src="/resource/img/15860668066361.jpg"></p>
<p><img src="/resource/img/15860668161669.jpg"></p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM-堆栈配置参数"><a href="#JVM-堆栈配置参数" class="headerlink" title="JVM 堆栈配置参数"></a>JVM 堆栈配置参数</h3><p><img src="/resource/img/15860671536079.jpg"></p>
<h3 id="jps-查看-JVM-进程启动参数"><a href="#jps-查看-JVM-进程启动参数" class="headerlink" title="jps 查看 JVM 进程启动参数"></a>jps 查看 JVM 进程启动参数</h3><p>默认元空间大小128M，最大元空间大小256M，初始化堆大小2G，最大堆大小5G，新生代512M，每个线程分配内存大小1M。eden空间和survivor空间的分配比率8:2，使用标记复制算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@xxx:/usr/lib/jvm/java-8-oracle/bin# ./jps -v</span><br><span class="line">1 xxx.jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -Xms2048m -Xmx5048m -Xmn512m -Xss1024k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<h3 id="jmap-生成堆快照"><a href="#jmap-生成堆快照" class="headerlink" title="jmap 生成堆快照"></a>jmap 生成堆快照</h3><p>format 指定输出格式，live 指明是活着的对象，file 指定文件名。方便后面通过分析工具分析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=dump.hprof pid</span><br></pre></td></tr></table></figure>

<h3 id="jstat-查看-JVM-进程已使用空间百分比"><a href="#jstat-查看-JVM-进程已使用空间百分比" class="headerlink" title="jstat 查看 JVM 进程已使用空间百分比"></a>jstat 查看 JVM 进程已使用空间百分比</h3><p><img src="/resource/img/15860681523977.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@xxx:/usr/lib/jvm/java-8-oracle/bin# ./jstat -gcutil 1</span><br><span class="line">  S0 S1 E O M CCS YGC YGCT FGC FGCT GCT</span><br><span class="line">  0.00 72.37 40.12 3.59 96.52 94.68 113 4.433 0 0.000 4.433</span><br></pre></td></tr></table></figure>

<p>S0 survivo0<br>S1 survivo1<br>E Eden空间<br>O 老年代<br>M 元空间使用率<br>CCS 压缩使用比例<br>YGC 新生代 GC 次数<br>YGCT 新生代 GC 耗时<br>FGC Full GC 次数<br>FGCT Full GC 耗时<br>GCT GC 耗时</p>
<h3 id="jmap-查看进程堆的详细信息"><a href="#jmap-查看进程堆的详细信息" class="headerlink" title="jmap 查看进程堆的详细信息"></a>jmap 查看进程堆的详细信息</h3><p><code>jmap -heap pid</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 3764, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.171-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 8 thread(s) //采用Parallel GC </span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio = 0 //JVM最小空闲比率 可由-XX:MinHeapFreeRatio=&lt;n&gt;参数设置， jvm heap 在使用率小于 n 时 ,heap 进行收缩</span><br><span class="line">   MaxHeapFreeRatio = 100 //JVM最大空闲比率 可由-XX:MaxHeapFreeRatio=&lt;n&gt;参数设置， jvm heap 在使用率大于 n 时 ,heap 进行扩张 </span><br><span class="line">   MaxHeapSize = 2095054848 (1998.0MB) //JVM堆的最大大小 可由-XX:MaxHeapSize=&lt;n&gt;参数设置</span><br><span class="line">   NewSize = 44040192 (42.0MB) //JVM新生代的默认大小 可由-XX:NewSize=&lt;n&gt;参数设置</span><br><span class="line">   MaxNewSize = 698351616 (666.0MB) //JVM新生代的最大大小 可由-XX:MaxNewSize=&lt;n&gt;参数设置</span><br><span class="line">   OldSize = 88080384 (84.0MB) //JVM老生代的默认大小 可由-XX:OldSize=&lt;n&gt;参数设置 </span><br><span class="line">   NewRatio = 2 //新生代：老生代（的大小）=1:2 可由-XX:NewRatio=&lt;n&gt;参数指定New Generation与Old Generation heap size的比例。</span><br><span class="line">   SurvivorRatio = 8 //survivor:eden = 1:8,即survivor space是新生代大小的1/(8+2)[因为有两个survivor区域] 可由-XX:SurvivorRatio=&lt;n&gt;参数设置</span><br><span class="line">   MetaspaceSize = 21807104 (20.796875MB) //元空间的默认大小，超过此值就会触发Full GC 可由-XX:MetaspaceSize=&lt;n&gt;参数设置</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB) //类指针压缩空间的默认大小 可由-XX:CompressedClassSpaceSize=&lt;n&gt;参数设置</span><br><span class="line">   MaxMetaspaceSize = 17592186044415 MB //元空间的最大大小 可由-XX:MaxMetaspaceSize=&lt;n&gt;参数设置</span><br><span class="line">   G1HeapRegionSize = 0 (0.0MB) //使用G1垃圾收集器的时候，堆被分割的大小 可由-XX:G1HeapRegionSize=&lt;n&gt;参数设置</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation //新生代区域分配情况</span><br><span class="line">Eden Space: //Eden区域分配情况</span><br><span class="line">   capacity = 89653248 (85.5MB)</span><br><span class="line">   used = 8946488 (8.532035827636719MB)</span><br><span class="line">   free = 80706760 (76.96796417236328MB)</span><br><span class="line">   9.978989272089729% used</span><br><span class="line">From Space: //其中一个Survivor区域分配情况</span><br><span class="line">   capacity = 42467328 (40.5MB)</span><br><span class="line">   used = 15497496 (14.779563903808594MB)</span><br><span class="line">   free = 26969832 (25.720436096191406MB)</span><br><span class="line">   36.49275037977431% used</span><br><span class="line">To Space: //另一个Survivor区域分配情况</span><br><span class="line">   capacity = 42991616 (41.0MB)</span><br><span class="line">   used = 0 (0.0MB)</span><br><span class="line">   free = 42991616 (41.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation //老生代区域分配情况</span><br><span class="line">   capacity = 154664960 (147.5MB)</span><br><span class="line">   used = 98556712 (93.99100494384766MB)</span><br><span class="line">   free = 56108248 (53.508995056152344MB)</span><br><span class="line">   63.722715216167906% used</span><br><span class="line"></span><br><span class="line">1819 interned Strings occupying 163384 bytes.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><p>目的：对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，减少系统停顿时间。</p>
<p>步骤：</p>
<ol>
<li>监控GC状态</li>
<li>生成 dump 文件</li>
<li>分析dump 文件（MAT 工具）</li>
<li>分析判断是否需要进行优化</li>
</ol>
<ul>
<li>Minor GC执行时间超过50ms；</li>
<li>Minor GC执行频繁，约10秒内一次；</li>
<li>Full GC执行时间超过1s；</li>
<li>Full GC执行频繁，高于10分钟1次；</li>
</ul>
<ol start="5">
<li>调整GC类型和内存分配</li>
<li>不断分析调整</li>
</ol>
<h2 id="可视化分析工具-MAT"><a href="#可视化分析工具-MAT" class="headerlink" title="可视化分析工具 MAT"></a>可视化分析工具 MAT</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wwlwwy89/article/details/74330544">https://blog.csdn.net/wwlwwy89/article/details/74330544</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nuniok</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.13.4/dist/mermaid.min.js","integrity":"sha256-96rwDGMWIQYB0yKGp1sKi1yrjrLPj2oT39IpbCsIrsg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"nuniok","repo":"nuniok.github.io","client_id":"Ov23liWEs17fH5aYPIzS","client_secret":"6bbfa4b5a042d38b10c942b5c15f4d8a3895e982","admin_user":"nuniok","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
